; MIT License
; 
; Copyright (c) 2023 Daniel Robertson
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
; 
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.

; This program pulls a 32-bit integer from application code and uses
; it to set the gain on the HX711. If an integer is not provided, the
; previously provided integer is used. A default integer of 0
; corresponding to a gain of 128 is used until an integer is provided.
; The integer provided should be in the range 0 to 2, inclusive.
; 
; This program constantly and automatically refills the ISR with the
; newest value from the HX711 without providing a gain value from
; application code.
; 
; The lower 24 bits contain the value from the HX711. The next (upper)
; bits should all be 0, but in any case should be ignored by
; application code.
; 
; Details are given on page 5 of the HX711's datasheet.
; 
; NOTES:
; 
; 1. This program assumes the state machine is running at 10MHz. Each
; instruction/cycle is therefore 100ns (0.1us).
; 
; 2. The 'x' register is used to store the last count of bits to read
; and to preload the OSR with if the OSR is empty. See pg. 350 of the
; RP2040 datasheet for details about this when the 'noblock' option is
; given.
; 
; 3. The 'y' register is used to as the decrement counter for the bit
; read counter. This variable is 0-based.
; 
; 4. When running in serial, there is an overlap between T2 and T3-T4.
; That is to say, the data pin can be read from 100ns after the clock
; pin has gone high. Given each bit is read in serial, the T2 delay is
; not needed.
; 
; 5. With the state machine running at 10MHz:
; 
; T1: With no delay following the wait instruction (ie. []), and
; assuming the the next instruction executes immediately after the wait
; condition is met, the clock pin will go high following that second
; instruction (ie. set pins, 1 [T3 - 1]). The set pins, 1 portion of
; the instruction will take one cycle - 100ns - which is the absolute
; minimum for T1 according to the HX711 datasheet.
; 
; T2: A T2 delay is still unneeded due to the inherent delays in
; reading the data pin and jmp instruction.
; 
; 6. There is a small speedup by side-setting on the gain loop jmp
; instruction.
; 
.program hx711_reader

.define PUBLIC HZ                   10000000

.define LOW                         0
.define HIGH                        1

.define READ_BITS                   23  ; 24 bits to read from HX711 (this is 0-based).
.define DEFAULT_GAIN                0   ; Default gain (0=128, 1=32, 2=64).
.define GAIN_BITS                   32
.define T3                          5   ; 500ns
.define T4                          5   ; 500ns

.side_set 1 opt             ; Side set on the clock pin.

set x, DEFAULT_GAIN         ; Set an initial default gain (this is 0-based).

pull noblock                ; Pull in gain from application, but don't block.
                            ; The effect is that if the TX FIFO is empty, the
                            ; OSR is loaded with the x register - the default.

out x, GAIN_BITS            ; Copy the OSR contents into the x register. If
                            ; the default is used, this is effectively a NOP.

.wrap_target
wrap_target:

set y, READ_BITS            ; Read y number of bits. This is 0-based.

; Edge-detect ready: only trigger on a falling edge of DOUT
wait HIGH pin 0             ; ensure DOUT has been high first
wait LOW pin 0              ; then wait for ready (falling edge)

bitloop:
    set pins, HIGH [T3 - 1] ; Set rising edge of clock pin.
    in pins, 1              ; Read bit from data pin into ISR. This will also
                            ; act as a 100ns delay for the clock pin high time.
    jmp y-- bitloop side LOW [T4 - 1] ; Keep jumping back to bitloop while y > 0,
                            ; also set the clock pin falling edge and delay for
                            ; 100ns after side-setting the clock pin before
                            ; looping or falling through to ensure a minimum
                            ; low clock pin for 200ns.

                            ; At this point, all 24 bits have been read
                            ; and can be pushed back to the application. A
                            ; manual 'push noblock' is not used in favour of
                            ; autopush, which is configured in the init
                            ; function below.

                            ; Defer obtaining the gain from the application
                            ; until the last moment. So:

    pull noblock side HIGH  ; Pull in any data if it's available, but don't
                            ; wait if there isn't any. If no data is there,
                            ; preload from x (this is what noblock does).
                            ; Also side-set the clock pin for the rising edge
                            ; of the 25th pulse.

    out x, GAIN_BITS        ; 
                            ; x will also
                            ; persist after the wrap loop. This instruction
                            ; doubles as a T3 delay for the 25th clock pulse.

    jmp !x after_post side LOW  ; If x is 0 (gain 128), skip extra pulses and go wait-for-high

                            ; If execution has fallen-through to here, the gain
                            ; is either 1 (32) or 2 (64). But if execution has
                            ; jumped back to wrap_target, copying x into y is
                            ; not needed. So:

    mov y, x                ; Copy x into y. y will hold the number of clock
                            ; pulses minus 1 to be used as the following loop
                            ; counter. This instruction doubles as a T4 delay
                            ; for the falling edge of the 25th clock pulse (
                            ; which is only really relevant to 26+ clock
                            ; pulses).

gainloop:
    set pins, HIGH [T3 - 1] ; Set clock pin high and delay to ensure a minimum
    in pins, 1              ; sample while high
                            ; high clock pin for 200ns.
    jmp y-- gainloop side LOW [T4 - 1] ; Keep pulsing clock pin while y > 0.
                            ; Also use this to side-set the falling edge of
                            ; the clock pin and delay for the minimum required
                            ; time. If this is the final loop, the extra delay
                            ; is superfluous but ultimately does not matter
                            ; because of the inherent delay in waiting on the
                            ; data pin again once the program wraps.

                            ; No need to read from the data pin.

                            ; At this point, the gain has been set for the
                            ; next reading, so go back to the start.
    after_post:
        wait HIGH pin 0
        jmp wrap_target
    ; Ensure HX711 has pulled DOUT high (busy) before re-arming

.wrap

% c-sdk {
// MIT License
// 
// Copyright (c) 2023 Daniel Robertson
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <assert.h>
#include <stddef.h>
#include "hardware/clocks.h"
#include "hardware/pio.h"
#include "hardware/structs/clocks.h"

void hx711_reader_pio_init(PIO pio,
                           uint sm,
                           uint offset,
                           uint data_pin,
                           uint clock_pin) {

    pio_gpio_init(pio, clock_pin);
    pio_sm_set_out_pins(pio, sm, clock_pin, 1);
    pio_sm_set_set_pins(pio, sm, clock_pin, 1);
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin, 1, true);

    pio_gpio_init(pio, data_pin);
    pio_sm_set_in_pins(pio, sm, data_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 1, false);
}



void hx711_reader_program_init(PIO pio,
                               uint sm,
                               uint offset,
                               uint data_pin,
                               uint clock_pin) {
    pio_sm_config cfg = hx711_reader_program_get_default_config(offset);

    const float div = (float)(clock_get_hz(clk_sys)) / (uint)hx711_reader_HZ;
    sm_config_set_clkdiv(&cfg, div);

    sm_config_set_set_pins(&cfg, clock_pin, 1);
    sm_config_set_out_pins(&cfg, clock_pin, 1);
    sm_config_set_sideset_pins(&cfg, clock_pin);
    sm_config_set_in_pins(&cfg, data_pin);

    sm_config_set_in_shift(&cfg, false, true, 24);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}

%}